/*
    Copyright (C) 2004-2025 Masaya YAMAGUCHI

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package jp.ac.ninjal.himawari;

import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.IntBuffer;
import java.nio.channels.FileChannel;
import java.util.ArrayList;
import java.util.ListIterator;
import java.util.regex.Pattern;

public class StandoffArgumentIndex extends ArgumentIndex {

	public final static String suffix = ".sax"; //$NON-NLS-1$

	private SIXDic sixdic;
	private ArrayList<Integer> iDic;
	private ListIterator<Integer> itDic;
	private int pResults[];
	private int iPResults = 0;
	private int iIdxBuf;
	
	private String textFieldName;
	private FieldInfo fieldInfo;
	private ArrayList<String> dicFieldNames;
	private int iDicText;
	private String columnNames[];
	
	private RandomAccessFile raIdx;
	private IntBuffer idxBuf;
	private FileChannel fc;
	private String idxFilename;
	private int iDicLimit;

	
	public StandoffArgumentIndex(String elementName, String argumentName,
			boolean isCompleteMatch, CorpusFile corpus, SIXDic sixdic) {
		super.elementName = elementName;
		super.argumentName = argumentName;
		super.isCompleteMatch = isCompleteMatch;
		this.sixdic = sixdic;
		this.idxFilename = corpus.getBasename() + "." + elementName + suffix; //$NON-NLS-1$
		dicFieldNames = sixdic.getFieldNames();
		iDicText = sixdic.getIndexText();
		columnNames = new String[dicFieldNames.size()];
		for(int i = 0; i < dicFieldNames.size(); i++){
			columnNames[i] = elementName + "\t" + dicFieldNames.get(i); //$NON-NLS-1$
		}
	}

	
	@Override
	boolean exists() {
		File idxFile = new File(idxFilename);
		return idxFile.exists();
	}

	@Override
	void open() throws IOException {
		raIdx = new RandomAccessFile(idxFilename, "r"); //$NON-NLS-1$
		fc = raIdx.getChannel();
		idxBuf = fc.map(FileChannel.MapMode.READ_ONLY, 0, raIdx.length())
				.asIntBuffer();
		iDicLimit = idxBuf.get();

		processedElement = elementName;
	}

	@Override
	void close() throws IOException {
		if (fc != null)fc.close();
		if (raIdx != null)raIdx.close();
		raIdx = null;
		idxBuf = null;

	}

	@Override
	void setRetrieveCondition(FieldInfo fieldInfo, String fieldName) {
		this.fieldInfo = fieldInfo;
		this.textFieldName = fieldName;
	}

	@Override
	boolean isOpen() {
		File idxFile = new File(idxFilename);
		return idxFile.exists();
	}

	@Override
	String getFilename() {
		return idxFilename;
	}

	@Override
	void mkaix(boolean isCompleteMatch) {
		System.err.println("Warning(StandoffArgumentIndex): this index is generated by mksix of StandoffElementIndex."); //$NON-NLS-1$
		return;
	}

	@Override
	ResultRecord retrieveFirst(String target) {
		if(isCompleteMatch){
			iDic = sixdic.search(argumentName, target, iDicLimit);
		} else {
			iDic = sixdic.searchRegex(argumentName, target, iDicLimit);
		}
		if(iDic.size() == 0){
			return null;
		}
		
		int iStart;
		itDic = iDic.listIterator();
		do {
			if(itDic.hasNext()){
				iIdxBuf = itDic.next();
			} else {
				return null;
			}
			idxBuf.position(iIdxBuf+1); // +1 means a. part (see storeData() in StandoffElementIndex)
			iStart = idxBuf.get();
		} while(iStart == -1);
		
		int iEnd = -1;
		
		int iNextIdxBuf = iIdxBuf+1;
		do {
			if(iNextIdxBuf <= iDicLimit){
				iEnd = idxBuf.get();
			} else {
				iEnd = idxBuf.limit();
			}
		} while(iEnd == -1);
		
		pResults = new int[iEnd-iStart];
		iPResults = 0;
		idxBuf.position(iStart);
		idxBuf.get(pResults);
		
		ResultRecord resultRecord = new ResultRecord(fieldInfo);
		resultRecord.setPosition(pResults[iPResults++]);
		ArrayList<String> dicItem = sixdic.get(iIdxBuf);
		
		if (filter == null || filter.size() == 0) { // フィルタが指定されていない場合
			for(int i = 0; i < dicFieldNames.size(); i++){
				if(i == iDicText){
					resultRecord.set(textFieldName, dicItem.get(i));
				} else {
					resultRecord.set(dicFieldNames.get(i), dicItem.get(i));
				}
			}
		} else {
			for(int i = 0; i < dicFieldNames.size(); i++){								
				if(i == iDicText){
					resultRecord.set(textFieldName, dicItem.get(i));
				} else {
					String columnName = columnNames[i];
					String columnValue = dicItem.get(i);

					Pattern filterValue = filter.get(columnName);

					if (filterValue != null) {
						if (filter.isNot(columnName)) { // 否定
							if (filterValue.matcher(columnValue).find()) {
								return retrieveNext();
							} else {
								resultRecord.set(columnName, columnValue);
							}
						} else {
							if (filterValue.matcher(columnValue).find()) {
								resultRecord.set(columnName, columnValue);
							} else {
								return retrieveNext();
							}
						}
					} else {
						resultRecord.set(columnName, columnValue);
					}
				}
			}
		}
			
		return resultRecord;
	}

	@Override
	ResultRecord retrieveNext() {
		int iStart;

		if(iPResults == pResults.length){
			iPResults = 0;
			do {
				if(itDic.hasNext()){
					iIdxBuf = itDic.next();
				} else {
					return null;
				}
				idxBuf.position(iIdxBuf+1); // +1 means a. part (see storeData() in StandoffElementIndex)
				iStart = idxBuf.get();
			} while(iStart == -1);
			
			int iEnd = -1;
			
			int iNextIdxBuf = iIdxBuf+1;
			do {
				if(iNextIdxBuf <= iDicLimit){
					iEnd = idxBuf.get();
				} else {
					iEnd = idxBuf.limit();
				}
			} while(iEnd == -1);
			
			
			pResults = new int[iEnd-iStart];
			iPResults = 0;
			idxBuf.position(iStart);
			idxBuf.get(pResults);
		}	
		
		ResultRecord resultRecord = new ResultRecord(fieldInfo);
		resultRecord.setPosition(pResults[iPResults++]);
		ArrayList<String> dicItem = sixdic.get(iIdxBuf);

		if (filter == null || filter.size() == 0) { // フィルタが指定されていない場合
			for(int i = 0; i < dicFieldNames.size(); i++){
				if(i == iDicText){
					resultRecord.set(textFieldName, dicItem.get(i));
				} else {
					resultRecord.set(dicFieldNames.get(i), dicItem.get(i));
				}
			}
		} else {
			for(int i = 0; i < dicFieldNames.size(); i++){								
				if(i == iDicText){
					resultRecord.set(textFieldName, dicItem.get(i));
				} else {
					String columnName = columnNames[i];
					String columnValue = dicItem.get(i);

					Pattern filterValue = filter.get(columnName);

					if (filterValue != null) {
						if (filter.isNot(columnName)) { // 否定
							if (filterValue.matcher(columnValue).find()) {
								return retrieveNext();
							} else {
								resultRecord.set(columnName, columnValue);
							}
						} else {
							if (filterValue.matcher(columnValue).find()) {
								resultRecord.set(columnName, columnValue);
							} else {
								return retrieveNext();
							}
						}
					} else {
						resultRecord.set(columnName, columnValue);
					}
				}
			}
		}

		return resultRecord;
	}

	@Override
	String getIOFilename() {
		return idxFilename;
	}
}
